"facebook/react"
"Do you want to request a feature or report a bug? Feature Right now babel plugin emits globals: #16604 It would be nice to have them configurable. That would allow to use import.meta in environments like SystemJS and have simpler implementation: If you don't mind I could create PR with changes to react-refresh/babel next week. environment:"
""
"Do you want to request a feature or report a bug? bug What is the current behavior? onMouseEnter is fired on disabled buttons. If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below: https://codesandbox.io/s/react-onmouseenter-on-disabled-buttons-fskwd What is the expected behavior? onMouseEnter shouldn't be triggered on disabled buttons. Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React? React 16.11.0 (not sure when it started to happen) Chrome/MacOS"
"Taking a look at this to see if I can fix it."
"Do you want to request a feature or report a bug? Feature (to catch potential bugs) What is the current behavior? The react-hooks/rules-of-hooks ESLint rule catches uses of hooks in conditionals in components, but does not recognise an anonymous function wrapped in forwardRef as a component. The following example breaks the rules of hooks, but isn't caught by the rule: What is the expected behavior? The above example should be caught by react-hooks/rules-of-hooks, and raise the ""React Hook ""useCustomHook"" is called conditionally"" error."
"I am learning React and Redux within a Typescript environment. I have managed to implement a container that dispatches a fetch action and subscribes to corresponding fetch success and error state notifications from a redux store. The source code is listed below: Container If I throw an error within the container then the encapsulating error boundary catches and displays it. However, when the container is reloaded via clicking on a Navbar link the useEffect action does not trigger. Subsequently, the fetchCourses action is not dispatched. Why is the useEffect hook not triggered on second load after it previously threw an error? My ErrorBoundary component includes a home button for navigating to '/'. However, after clicking home, if I then click on link to display my CourseList container the ErrorBoundary is again displayed. I do not see the console log message displayed from useEffect. When navigating back to '/courses' shouldn't this recreate the CourseList container? Is this not happening because the error was thrown in render previously, so the container is being reused? What is best practice for resetting a component that threw an error for surrounding ErrorBoundary?"
"Do you want to request a feature or report a bug? Bug What is the current behavior? The React devtools tabs in Chrome devtools can be displayed in extension pages, even though modifying extensions in other extensions is not supported by Chrome, and React devtools are therefore broken. If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below: Example: prettier-chrome-extension (install from source and open extension options) What is the expected behavior? React devtools should not appear when it's not supported, just like when devtools are opened on a page that doesn't use React. Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?"
"Assigning to myself because I'm interested."
"This comment on a similar issue could be useful: The intuitive way [to detect chrome-extension pages] is to check location.protocol. #8409 (comment) There's also a pull request: #10359"
"I'm not able to reproduce this behavior."
"I can reproduce with a fresh install of the example: prettier-chrome-extension (install from source and open extension options)"
"What is the current behavior? TypeError: Do not know how to serialize a BigInt which makes it so the react dev tools cannot inspect the component props. Steps to reproduce You can repro this with the following https://codesandbox.io/s/mystifying-cache-jshv3 Note that you need to repo via Chrome DevTools so that the bridge is active, if you use the codesandbox built-in DevTools the behavior is different. What is the expected behavior? That bigints are handled in a similar way to how symbols are handled. So that they don't crash when they cross a boundary, i.e. postMessage. Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React? Latest version, hasn't worked before. That I know. Tested in Chrome and Firefox, although the behavior isn't exactly the same in Firefox as in Chrome, it doesn't appear to work in Firefox either. I would like to propose a fix for this but I cannot find where in the source this would go. I don't care for editing capabilities and such, I just don't want the dev tools to give up on my just because I have BigInts in my code."
"i would like to work on this bug fix, Please provide inputs admin"
"Hi John , @leidegre react\packages\react-devtools-extensions\src\backend.js const {initBackend} = require('react-devtools-shared/src/backend'); initBackend(hook, agent, window); the initBackend method is rendering the component along with the props you have defined, please make use of the below backendjs and indexjs in shared to check on more, \react\packages\react-devtools-shared\src\backend\index.js export function initBackend(); I also would like to contribute to the issue, if you have time this weekend or some other date, lets sit and look into it.We can discuss in the Discord, in PST discord id-abrahamwilliam007"
"@abrahamwilliam Sorry I didn't track your comments. I started work on this issue and already opened a PR. Feel few to review. We may come up some better workaround."
"With Concurrent mode getting finalized, I went to try to solve an old problem I have. The app needs to run a series of init steps before it can do anything viable. Each steps depends on the previous one. This is expressed as nested components. The fairly elaborate animated logo is shown for that process, but it's being restarted for each step and the experience is not that nice. I've prepared a demo with some experiments: https://codesandbox.io/s/react-suspense-loader-experimental-0ww6i The first one that's active initially is what we currently have. The second is what we would like to have, but with less naive coding of decreasing counter. The last one is my attempt to use Suspense, but I definitely missing something out here, because it behaves very oddly and I cannot seem to figure out why. I wonder if the new useTransition should be used somehow or what's going on here."
"I think the problem is that when a component suspends while mounting, it doesn't get mounted at all. So none of its effects (like your useTimeoutFn) get called. The best way to achieve what you're trying to do is to separate the firing of the promises, from throwing them in suspended components, like what React does in the fakeAPI it used in the concurrent mode documentations"
"@Eddie-CooRo Thanks for the reply. I've adapted the example according to your advice. https://codesandbox.io/s/react-suspense-loader-experimental-0f0eo Unfortunately, Suspense is actually remounting that loader as well for each step ðŸ˜® I even moved Suspense upper in the tree to be sure it's not a different problem. Perhaps I've misunderstood how is it supposed to work? I thought that fallback will be kept mounted as long as something is suspended, but I guess because there is actually a moment where the next step is rendered and nothing is suspended, it won't keep that loader around. It's strange, I thought Suspense is kinda supposed to solve the problem of centralized loading indicators, but I guess my use case is somewhat rare and I have to handle it some other way."
"Hi again @freddyrangel, sorry for the delay. The flash of the fallback component is because your StepSim component doesn't suspend on mount, but it suspends later after setting its state to 'exec.' So at some point, there is one time when none of the components suspend, and during that short amount of time, there is no need for the fallback to show up. I think what you are trying to achieve is possible this way: (It's a very simple demonstration) Demo: https://codesandbox.io/s/react-suspense-loader-experimental-d1271"
"Hm, I don't follow what's different? It still behaves the same way and remounts the loader. component doesn't suspend on mount, I am confused. Before you have said it's wrong to suspend while mounting and now it's something I actually want? My brain is totally suspended from all this ðŸ˜†"
"Sorry if I wasn't able to explain correctly what is happening in your example. Let me try one more time. ðŸ˜… So, there are two different things to examine, Firstly, when a component suspends during its mount, none of its effects get called, and neither its state gets persisted. Let's think about that this way, the useEffect documentation says: effects run after every completed render So when a component suspends, nothing gets rendered; therefore, React doesn't call any of its effects. But it's not a Problem by itself. It's a Behavior, and it tells us that when our component suspends, it shouldn't rely on any of its effects, or ref/state s to un-suspend correctly. Secondly, When we first let the component to mount before suspending it, for a short amount of time, the fallback doesn't show up because everything is rendered without suspending (but our component is returning ""null"" as its children). So this is the order of events, starting with the suspension of the step1 component: So at one point in time(when we are at event number 6), there will be nothing displayed on the screen, and this will result in flashing of the fallback component for a second But the order of the events for the example I sent in the previous comment, is different: So the fallback component stays mounted on the screen all the time."
"Do you want to request a feature or report a bug? Probable Bug What is the current behavior? When an empty object is passed as SuspenseConfig, React waits infinitely on the previous tree for new Suspended components to get resolved. A minimal demo of the problem: Here is a demonstration, using the same example used throughout the concurrent docs: https://codesandbox.io/s/empty-suspense-config-example-88ghb What is the expected behavior? I don't know if it's a bug, or it's intentional. But if it's the expected behavior, I think it's better to add this to the documentation. Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React? React and ReactDOM's experimental build"
"Your codesandbox demo appears to be working as expected for me in Chrome 77.0.3865.120."
"@sadlittlejoe This behavior is exactly what I want to report Because the documentation hasn't mentioned that when passing an empty object as the SuspenseConfig, the fallback component never shows up"
"Do you want to request a feature or report a bug? Outdated README (maybe?) What do the docs currently say? use-subscription is safe to use in concurrent mode. However, it achieves correctness by sometimes de-opting to synchronous mode, obviating the benefits of concurrent rendering. In the linked issue, @bvaughn explains that this is referring to chains of synchronous updates using componentDidUpdate. However, the useSubscription hook now uses a passive useEffect(), as opposed to a synchronous componentDidUpdate(). Would this mean that it's no longer ""de-opting to sync mode"", and the warning could be removed from the README?"
